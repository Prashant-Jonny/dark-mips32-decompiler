\section{Domain-specific language}

In the previous section.~\ref{section:problem-statement} we described
the \emph{core} issues that our solution needs to address. 

Summarizingly, we found that we want to be able to

\begin{itemize}
\item Get the six left-most bits from a 32-bit integer,
  i.e. the numerical opcode.
\item Infer the Format of the instruction from the opcode.
\item When necessary consult additional bitfields in the 32-bit integer to
      determine the particular instruction.
\item Validate other bitfields when necessary.
\item Convert the numerical representation into a mnemonic representation.
\end{itemize}

The first two items are trivial, the first is the result of a
bit-shift operation and as alluded to previously the Format is always
inferrable from the Opcode, which means that we can either let each
opcode know its associated format or similarily associate formats
with sets of opcodes elsewhere. The specific approach will be covered
later, as will the reason it was chosen.

The subset of the MIPS32-instruction set that we have
implemented,\footnote{Floating point operations and a few others have
  been omitted.} is made up of a large number of operations so we would
like to design our system in such a manner that all of this
\emph{knowledge} pertaining to a particular instruction, viz. how to
validate it and represent it, be stored in a single place.

We want to express this as succinctly as possible, to make it as
legible as possible in one place all the defining characteristics
of an instruction.

Regardless of the instruction type we can express an instruction
as a tuple,

\begin{equation*}
(\langle \textit{identifying characteristics} \rangle, \langle
  \textit{validation requirements} \rangle, \langle \textit{mnemonic
    representation} \rangle)
\end{equation*}

For the R-type instructions we have that the identifying
characteristics is always expressed as a pair $(\textit{opcode},
\textit{funct})$, and that an I-type instruction is either identified
solely by its \opcode or by the pair $(\textit{opcode}, \textit{rt})$
in the case where \tt{opcode=0x01}, and J-type instructions are always
identified solely by their opcode.

Certain instructions must fulfill various conditions to be completely
valid. For an example, the instruction \texttt{MTC0} is identified by
$(\textit{opcode=0x10}, \textit{funct=0x00})$. To be valid, \tt{rs}
needs to be \tt{0x04}, while \tt{shamt} has to be \tt{0x00}.

Furthermore, its associated mnemonic pattern is \pattern{iname, rd, rt}.

Encoding this knowledge at a single point is done in an enum declaration,

\begin{minted}[bgcolor=mintedbackground]{java}
/**
 * Move to coprocessor 0, move CPU register rt to register
 * rd in a coprocessor
 */
MTC0(0x10, 0x00, new Condition<RTypeInstruction, Integer>()
        .checkThat("rs", Int::rs).is(0x04).
                andThat("shamt", Int::shamt).is(0x00),
        new MnemonicPattern<>(Str::iname, Str::rd,  Str::rt)),
\end{minted}
