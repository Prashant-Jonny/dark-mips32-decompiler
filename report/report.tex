\documentclass[a4paper]{article}

% Enables the inclusion of images using
% the \includegraphics directive
\usepackage{graphicx}
\usepackage{float}
% Specify date format
\usepackage[yyyymmdd]{datetime}

% Allows forceful placement of figures
% using the [H] option for figures.
\usepackage{float}

\usepackage{booktabs}

% Replace paragraph-indents with linebreaks between paragraphs
\usepackage{parskip}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

% Used for nice page headings.
\usepackage{fancyhdr}
\usepackage{lastpage}

% Allows us to define our own macros
\usepackage{letltxmacro}
\LetLtxMacro\tt\texttt
\LetLtxMacro\mi\mintinline

\newcommand{\opcode}{Opcode\ }
\newcommand{\format}{Format\ }
\newcommand{\integer}{Integer32\ }
\newcommand{\opcodem}{\mintinline{java}{Opcode}\ }
\newcommand{\formatm}{\mintinline{java}{Format}\ }
\newcommand{\instructionm}{\mintinline{java}{Instruction}\ }
\newcommand{\decomposedm}{\mintinline{java}{DecomposedRepresentation}\ }
\newcommand{\mnemonicm}{\mintinline{java}{MnemonicRepresentation}\ }
\newcommand{\registerm}{\mintinline{java}{Register}\ }
\newcommand{\mij}[1]{\mintinline{java}{#1}}

\usepackage{xcolor}
\definecolor{mintedbackground}{rgb}{0.95,0.95,0.95}
\usepackage{xspace}
\usepackage{hyperref}
\hypersetup{
  colorlinks = true, % Colours links instead of ugly boxes
  urlcolor = blue, % Colour for external hyperlinks
  linkcolor = blue, % Colour of internal links
  citecolor = red % Colour of citations
}


\definecolor{inlinecode}{rgb}{0.85,0.85,0.85}

% Enclose your code snippets with \hlc{code} to
% monospace the text and highlight it
\usepackage{soul}
\newcommand{\hlc}[2][inlinecode]{{\sethlcolor{#1} \texttt{\hl{#2}}}}

\usepackage{listings}
\usepackage{pdflscape}
\usepackage{caption}
\usepackage{geometry}
\renewcommand\dateseparator{-}

\newcommand{\department}{Department of Computing Science}
\newcommand{\uni}{Ume\aa\ University}

\newcommand{\me}{Filip Allberg (\texttt{filip@cs.umu.se})}
\newcommand{\name}{MIPS32-decompiler}
\title{\name}
\author{\me}
\newcommand{\coursename}{Computer Organization and Architecture\xspace}
\newcommand{\coursecode}{5DV118}
\newcommand{\instructor}{Stephen Hegner, Thomas Johansson}

\pagestyle{fancy}

\begin{document}

\raggedbottom

\date{}
\begin{titlepage}
\maketitle

\fancyfoot{}

\thispagestyle{fancy}
\headheight 35pt

\lhead{\small \department \\
\uni} % These two are also defined in config.sty

\rhead{\small \today} %date


\cfoot{\coursename \coursecode HT15, 7.5 hp\\
Supervisor(s): \instructor}

\end{titlepage}


% Header settings
\fancyhead[LE,RO]{\thepage(\pageref{LastPage})}
\fancyheadoffset[LE,RO]{12mm}
\fancyhead[LO,RE]{\coursename: \title \\ \me}
\fancyfoot[L,R,C]{}

\tableofcontents

\section{Introduction}

In the MIPS32 architecture, all machine instructions are represented
as 32-bit numbers. This article presents a MIPS32-decompiler that,
when passed 32-bit numbers which either partially or completely
represent MIPS32 instructions yields a series of different
representations of the same instruction.

Specifically, MIPS32 instructions are to be read from a file with
numbers either in decimal or hexadecimal form. For each number in the
input file, the disassembler will produce the following:

\begin{itemize}
  \item The number from the input file.
  \item The format of the instruction (R, I, or J).
  \item The decomposed representation in decimal.
  \item The decomposed representation in hexadecimal.
  \item The representation of the instruction in mnemonic format,
    using register abbreviations wherever possible (e.g.,
    \texttt{\$t0} instead of \texttt{\$8}) and using decimal numbers
    whenever actual numbers are necessary.
\end{itemize}

In the following subsections an introduction of the terminology used
throughout this document is provided. Afterwards you may refer to this
section again if any of the above requirements seem foreign to you.

The rest of the document will be dedicated to a high-level description
of this solution accompanied with a guide on how to compile and run
the software.

The appendix contains an overview of all those instructions that the
decompiler is capable of comprehending.
\subsection{Terminology}

% TODO: cite
According to Aho et al.  a \emph{compiler} is a program that
can read a program in one language --- the \emph{source} language --
and translates it into an equivalent program in another language --
the \emph{target} language; see Fig.~\ref{fig:compiler}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{figures/compiler.png}
  \caption{A compiler}
  \label{fig:compiler}
\end{figure}

Conversely, a \emph{decompiler} is also a that performs the reverse
operation of a compiler. It too, is a compiler. Commonly one views a
compiler as a translator from a high-level human-readable source
language into a low-level machine-readable language, similarly a
decompiler translates in the opposite direction; see
Fig. \ref{fig:decompiler}. 

The two exhibit a chiral relation to one another, i. e. that they are
mirrored images of each other in terms of functionality, but they are
not themselves identical.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{figures/decompiler.png}
  \caption{A decompiler}
  \label{fig:decompiler}
\end{figure}

In this assignment the decompiler must be able to translate from the
machine-readable language of 32-bit numbers representing MIPS32
instructions to the human-readable target language described in the
introduction.

The constituent parts of the decompilers output will
be described further in section.~\ref{section:mul-example}.

Specifically,

\begin{itemize}
  \item Format.
  \item Opcode.
  \item Decomposed representation.
  \item Mnemonic representation.
\end{itemize}

will be covered. We will augment this list later on.
\subsubsection{Example: Decomposing \texttt{mul}}\label{section:mul-example}

Consider the 32-bit number \texttt{0x71014802}. It is
\emph{decomposed} into fields of varying lengths depending on the
\emph{format} of the instruction.

For all numbers in the MIPS32 instruction set the leftmost six bits
always represent the opcode for the instruction. The opcode alone is
not always sufficient to identify the particular instruction,
\emph{but} it is always sufficient to identify the format of the
instruction.

The leftmost six bits of \texttt{0x71014802} is \texttt{0x1c}. It is
\emph{known} that this number corresponds to an instruction in the
R-format. The format specifies into which fields the remaining bits
decompose into. In Fig. \ref{fig:r-decomposed} each field's size in
bits is the small number below the field.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/r-decomposed.png}
  \caption{The fields of an R-type instruction}
  \label{fig:r-decomposed}
\end{figure}

As alluded to previously, all instructions may not be discerned by
their opcode alone. This holds for all R-type instructions.

Decomposing \texttt{0x71014802} into the fields shown in
Fig. \ref{fig:r-decomposed} yields \texttt{rs=8}, \texttt{rt=1},
\texttt{rd=9}, \texttt{shamt=0}, and \texttt{funct=2}. The
\emph{decomposed representation} of this instruction in hexadecimal
form is thus \texttt{[0x1c 8 1 9 0 2]}.\footnote{The corresponding
\emph{decimal representation} is \texttt{[28 8 1 9 0 2]}}

To identify the particular instruction represented by
\texttt{0x71014802} the \texttt{funct} field must be
consulted. Pairing the opcode, \texttt{0x1c} and the value in the
\texttt{funct} field uniquely identifies the instruction a
\texttt{mul} instruction; see Fig. \ref{fig:mul-decomposed}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/mul-decomposed.png}
  \caption{Decomposition and mnemonic representation of \texttt{mul}}
  \label{fig:mul-decomposed}
\end{figure}

From Fig.~\ref{fig:r-decomposed} the registers \texttt{rs},
\texttt{rt} and \texttt{rd} were determined to have the addresses 8,
1, and 9, respectively. In MIPS registers are named, following the
convention shown in Table. \ref{table:mips-register-naming-convention}

\begin{table}[H]
\centering
\caption{MIPS register naming convention}
\begin{tabular}{ll}
\toprule
Nickname & Register Number \\
\midrule
\$zero      & 0            \\
\$at        & 1            \\
\$v0 - \$v1 & 2 - 3        \\
\$a0 - \$a3 & 4 - 7        \\
\$t0 - \$t7 & 8 - 15       \\
\$s0 - \$s7 & 16 - 23      \\
\$t8 - \$t9 & 24 - 25      \\
\$k0 - \$k1 & 26 - 27      \\
\$gp        & 28           \\
\$sp        & 29           \\
\$fp        & 30           \\
\$rd        & 31           \\
\bottomrule
\end{tabular}
\label{table:mips-register-naming-convention}
\end{table}

Replacing the numerical values of \texttt{rs}, \texttt{rt} and
\texttt{rd}, with their named counterparts yields the \emph{mnemonic
representation} of the instruction to be

\begin{center}
  \texttt{mul \$t1, \$t0, \$at}
\end{center}

\section{Problem statement}\label{section:problem-statement}

In this assignment the core functionality which is exposed is
\emph{parsing} such a 32-bit number representing an instruction from
the MIPS32-instruction set and outputting other representations of the
same instruction, as well as some additional information regarding the
very same instruction, see Fig. \ref{fig:mips32-decompiler}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/mips32-decompiler.png}
  \caption{Input and output of the decompiler}
  \label{fig:mips32-decompiler}
\end{figure}

Therefore, we need to be able to identify the appropriate format (from
which we can infer the decomposition), the identity of the particular
instruction (so that we can get its name) and also interpret the
constituent bitfields of the instruction so that we output a mnemonic
representation of the instruction.

In the previous section we established the terminology we will use
throughout the document. This terminology will also be used to
decompose our system that solves the problem at hand, viz. that
we will model our solution according to the problem domain.

Specifically, we will create a system such that when we take in a
32-bit integer representing a valid or semi-valid MIPS32-instruction
then we can construct an object instance named \mij{Instruction} that
knows, or can retrieve information about,\footnote{Using its
collaborators}

\begin{table}
\begin{itemize}
\item Its numerical representation
\item Its own format
\item Its own decomposed representation presented in both:
\subitem Hexadecimal form
\subitem Decimal form
\item Its own mnemonic representation
\end{itemize}
\caption{\mij{Instruction} operations/fields}
\label{table:instruction-operations}
\end{table}

The \mij{Instruction} class is an abstraction providing an
encapsulation around the aforementioned points. Ultimately, the system
will be divided into the self-explanatory constituents

\begin{itemize}
\item \formatm: R, I, J
\item \opcodem: An abstraction around the numerical opcode.
\item \formatm: Can for a given \opcodem return the associated format.
\item \decomposedm: Can decompose a 32-bit number into varying lengths.
\item \registerm: Associates a number with the register name, 
      see Table.~\ref{table:mips-register-naming-convention}
\end{itemize}

The \emph{core} issues to address is that of identifying the
instruction, validating the values of the bitfields of the
instruction, and outputting it according to some \emph{pattern}.

We will now address these issues in more detail, and create a running
tally of functionality that we would like to express within our
system. Afterwards we will define a facsimile of a domain-specific
language (DSL) that will encode the items we touch upon here.

\subsection{Identifying the instruction}\label{section:identification}

Recall from our earlier example where we decompiled a \tt{mul}
instruction that the \opcode is always sufficient to identify
the format of the instruction it is not always sufficient to
identify an instruction uniquely.

We find that all J-type instructions and for some, but not all, I-type
instructions the \opcode will suffice. Specifically, those I-type
instructions which cannot be identified by their opcode alone is the
branch instructions and immediate trap operations.

For the opcodes \tt{op=0x00}, and \tt{op=0x1c} it is necessary to
consult a second field in order to identify the instruction
completely, namely the \tt{funct} field. For instructions with the
opcode \tt{0x01} the \tt{rt} field must instead be consulted.

Therefore, we would like to compose a system that may

\begin{itemize}
\item Get the six left-most bits from a 32-bit integer, i.e. the numerical opcode.
\item Infer the Format from the opcode.
\item When necessary consult additional bitfields in the 32-bit integer to
      determine the particular instruction.
\end{itemize}

\subsection{Validating the non-identifying bitfields}\label{section:validation}

Consider the 32-bit integer \tt{0x00012122}. This number represents an
instance of the \tt{sub} instruction. It is identified by
having its opcode set to \tt{0x00} and its funct field to \tt{0x22}.
\emph{But}, it is not \emph{valid} if its shamt field is not also set to 0.

This validation step needs to be incorporated somehow. It would be
naive to consider this an additional consultation of a bitfield to
determine identity, since we could not distinguish between whether or
not the correct instruction has been identified or if there is a
problem in the validation.

Hence, our system should be able to (once the particular instruction
has been identified) validate the instruction.

\subsection{Patternizing output}\label{section:patternizing}

We have not addressed this before but the mnemonic representation of
instructions in the MIPS32 instruction set has a tendency to follow a
certain pattern, and these patterns are dependent upon the format of
the particular instruction.

For an example, the instructions

\begin{verbatim}
add, addu, sub, mul, and, or, nor, xor, movn, movz
\end{verbatim}

\newcommand{\pattern}[1]{\emph{$\langle$#1$\rangle$}}
among possibly others, have the common pattern \pattern{iname, rd, rs,
rt} with \emph{iname} being the name of the instruction.

Other common patterns include 

\begin{itemize}
\item \pattern{iname rd, rs}
\item \pattern{iname rd, rt, rs}
\item \pattern{iname, rd, rt, shamt}
\end{itemize}

for R-format instructions and

\begin{itemize}
\item \pattern{iname, rt, rs, imm}
\item \pattern{iname rt, imm}
\item \pattern{iname, rt, rs(addr)}
\end{itemize}

for I-format instructions.

Being a RISC architecture we would expect these patterns to favor
regularity, and that maybe the above set would suffice but there
are in fact numerous others.

As such we will want to, for each instruction, associate it with its
output pattern.

\section{Usage and compilation}

We will now describe how to compile and use the supplied software,
so that you may experiment with it later when the solution is
described.

The source code may be downloaded at the following two addresses,

\begin{center}
\url{https://github.com/leksak/dark-mips32-decompiler.git} \\
\url{git@github.com:leksak/dark-mips32-decompiler.git}
\end{center}

Or viewed in the following folder
\hlc{{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$}}filip/edu/dark-mips32-decompiler} on the institution's network.

For the duration of this report the directory created by cloning
the repository is referred to as the \emph{root directory}.

\section{Compilation and usage}

In this section the compilation of the software is described as
is the usage of the software

\subsection{Compilation}

Navigate to the root directory of the project.

Whilst there execute the following command to compile the program:

\begin{minted}[bgcolor=mintedbackground]{bash}
$ gradle jar
\end{minted}

In the \hlc{build/libs} directory you will now find a file named
\hlc{MIPS32Decompiler.jar} which you can run using \hlc{java -jar
  MIPS32Decompiler.jar} given that you have Java 8 shown when running
\hlc{java -version}.

\subsubsection{Compiling and running tests}

From the root directory navigate to the \hlc{java} directory.
Whilst there execute the following command to compile and run the tests:

\begin{minted}[bgcolor=mintedbackground]{bash}
$ gradle test
\end{minted}

The results of the tests will be placed in the \hlc{build/reports/tests}
directory. To view the results of the tests open, in a browser, 
the \hlc{index.html} in the aforementioned folder.

In figure~\ref{fig:tests} the output yielded by the tests is shown.

\begin{landscape}
\thispagestyle{plain}
\cfoot{}
\begin{figure}[htpb]
\centering
\includegraphics[scale=0.4]{img/tests.png}
\caption{Test results}
\label{fig:tests}
\end{figure}
\end{landscape}


On the aforementioned page, \hlc{index.html}, you may navigate through
the different packages and view the results for specific tests.

\subsection{Usage}

The program supplies two means of interfacing with it, by calling
the program with 0 arguments or the \hlc{-h} flag we can get the
user guide supplied with the software

\begin{minted}[bgcolor=mintedbackground]{bash}
$ java -jar build/libs/MIPS32Decompiler.jar -h
Usage: MIPS32Decompiler [OPTION] <number|file>...
OPTIONS:
    -n Specifies that input should be read from 
       from the command-line. The following 
       argument(s) may either be a number in hexadecimal form
       or decimal form. Hexadecimal numbers must be
       preceded by the 0x prefix.
    -h Shows this help message.
If no option is passed, the argument(s) passed is
assumed to be path to a filename
\end{minted}

\subsubsection{Decompiling source code from files}

The default setting is that the software interprets its given input
arguments as a filenames, relative to the directory from which you
execute the \tt{.jar} file. In the root directory of the project three
example files are included.

\tt{sample-program.txt} showcases the tabulated output for several
instructions, as well as how error messages for partially legal
instructions are written out.

\tt{sample-decimal.txt} showcases that the program is capable
of handling instructions in base 10. The file ends with
a trailing blank line, which is not a problem for the software.

\tt{sample-mingled.txt} demonstrates that the program does not expect
the file to be written consistently in either base 10 or base 16 but
evaluates this on a per-line basis. A number is interpreted
to be in base 16 if it is prefixed by \tt{0x}. The two numbers
are separated by a blank-line which does not pose an issue.

We can inspect the contents of these files using \hlc{cat}
as shown in Listing.~\ref{listing:sample-input-files}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[basicstyle=\small, 
    language=bash, 
    caption=Sample input files,
    label=listing:sample-input-files,
    backgroundcolor=\color{mintedbackground}]
$ cat sample-decimal.txt 
599654392

$ cat sample-mingled.txt 
599654392

0xafbf0004
$ cat sample-program.txt 
0x23bdfff8
0xafbf0004
0xafa40000
0x28880001
0x11000003
0x20020001
0x23bd0008
0x03e00008
0x2084ffff
0x0c100000
0x8fa40000
0x8fbf0004
0x23bd0008
0x70821002
0x03e00008
0x00012122
\end{lstlisting}
\end{minipage}

Similarly we may observe the output of our decompiler in
Listing.~\ref{listing:tabularized-output}, where the
files are passed as a series of arguments.

\begin{landscape}
\begin{minipage}{\linewidth}
\thispagestyle{empty}
\begin{lstlisting}[ 
    language=bash, 
    caption=Tabularized output,
    breaklines=false,
    label=listing:tabularized-output,
    backgroundcolor=\color{mintedbackground}][htpb]
$ java -jar build/libs/MIPS32Decompiler.jar \
sample-mingled.txt sample-decimal.txt sample-program.txt
Instruction     Fmt Decomposition   Decomp hex             Source            
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
0xafbf0004      I  [43 29 31 4]    [0x2b 0x1d 0x1f 4]     sw $ra, 4($sp)    
Instruction     Fmt Decomposition   Decomp hex             Source            
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
0xafbf0004      I  [43 29 31 4]    [0x2b 0x1d 0x1f 4]     sw $ra, 4($sp)    
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
Instruction     Fmt Decomposition   Decomp hex             Source            
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
0xafbf0004      I  [43 29 31 4]    [0x2b 0x1d 0x1f 4]     sw $ra, 4($sp)    
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
0xafbf0004      I  [43 29 31 4]    [0x2b 0x1d 0x1f 4]     sw $ra, 4($sp)    
0xafa40000      I  [43 29 4 0]     [0x2b 0x1d 4 0]        sw $a0, 0($sp)    
0x28880001      I  [10 4 8 1]      [0xa 4 8 1]            slti $t0, $a0, 1  
0x11000003      I  [4 8 0 3]       [4 8 0 3]              beq $t0, $zero, 3 
0x20020001      I  [8 0 2 1]       [8 0 2 1]              addi $v0, $zero, 1
0x23bd0008      I  [8 29 29 8]     [8 0x1d 0x1d 8]        addi $sp, $sp, 8  
0x03e00008      R  [0 31 0 0 0 8]  [0 0x1f 0 0 0 8]       jr $ra            
0x2084ffff      I  [8 4 4 65535]   [8 4 4 0xffff]         addi $a0, $a0, -1 
0x0c100000      J  [3 1048576]     [3 0x100000]           jal 0x100000      
0x8fa40000      I  [35 29 4 0]     [0x23 0x1d 4 0]        lw $a0, 0($sp)    
0x8fbf0004      I  [35 29 31 4]    [0x23 0x1d 0x1f 4]     lw $ra, 4($sp)    
0x23bd0008      I  [8 29 29 8]     [8 0x1d 0x1d 8]        addi $sp, $sp, 8  
0x70821002      R  [28 4 2 2 0 2]  [0x1c 4 2 2 0 2]       mul $v0, $a0, $v0 
0x03e00008      R  [0 31 0 0 0 8]  [0 0x1f 0 0 0 8]       jr $ra            
0x00012122      R  [0 0 1 4 4 34]  [0 0 1 4 4 0x22]       sub $a0, $zero, $at
  Errors: shamt: Got: 4 Expected: 0
\end{lstlisting}
\end{minipage}
\end{landscape}

The table headers, see Listing.~\ref{listing:table-headers}

\begin{minipage}{\linewidth}
\begin{lstlisting}[basicstyle=\small, 
    language=bash, 
    caption=Table headers,
    label=listing:table-headers,
    backgroundcolor=\color{mintedbackground}]
Instruction     Fmt Decomposition   Decomp hex             Source
\end{lstlisting}
\end{minipage}

are written out before each file decompilation, refer to
Listing.~\ref{listing:tabularized-output} to see that this is true
when multiple input files are specified.

\subsubsection{Decompiling input numbers}

Additionally, the software provides a secondary means of use, through
the \hlc{-n} flag which stands for \emph{number} so that the arguments
immediately following the invocation of the program are interpreted
as if they were contents in a file. Notice in 
Listing.~\ref{listing:parsing-numbers-from-input-arguments} that it does not matter
whether or not the number is in base 10 or base 16 (as long as numbers in
base 16 are prefixed by \tt{0x}).

\begin{minipage}{\linewidth}
\begin{lstlisting}[basicstyle=\small, 
    language=bash, 
    caption=Parsing numbers from input arguments using the \texttt{-n} flag,
    label=listing:parsing-numbers-from-input-arguments,
  backgroundcolor=\color{mintedbackground}]
$ java -jar build/libs/MIPS32Decompiler.jar -n \
> 599654392 0xafbf0004
Instruction     Fmt Decomposition   Decomp hex             Source            
0x23bdfff8      I  [8 29 29 65528] [8 0x1d 0x1d 0xfff8]   addi $sp, $sp, -8 
0xafbf0004      I  [43 29 31 4]    [0x2b 0x1d 0x1f 4]     sw $ra, 4($sp)    
\end{lstlisting}
\end{minipage}

Lastly, note that the software handles partially valid instructions,
i.e. instructions that may be correctly identified but validates some
condition. For instance, the number \tt{0x00012122} corresponds to the
\tt{sub} instruction. The number decomposes into bitfields according
to the format of the instruction (viz. the R-format), and the opcode
and funct field hold the correct values to identify the instruction as
a \tt{sub} instruction \emph{but} the \tt{shamt} field is not set to
4, which it has to be according to the instruction specification.

When an instruction is partially legal the violating fields are outputted
on the following line, see Listing.~\ref{listing:partially-valid-instructions}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[basicstyle=\small, 
    language=bash, 
    caption=Error print-outs for partially valid instructions,
    label=listing:partially-valid-instructions,
  backgroundcolor=\color{mintedbackground}]
$ java -jar build/libs/MIPS32Decompiler.jar -n 0x00012122
Instruction     Fmt Decomposition   Decomp hex             Source            
0x00012122      R  [0 0 1 4 4 34]  [0 0 1 4 4 0x22]       sub $a0, $zero, $at
  Errors: shamt: Got: 4 Expected: 0
\end{lstlisting}
\end{minipage}

If there are multiple conditions that are violated, they are all
specified in the error column, see Listing.~\ref{listing:multiple-errors}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[basicstyle=\small, 
    language=bash, 
    caption=Multiple errors,
    breaklines=false,
    label=listing:multiple-errors,
  backgroundcolor=\color{mintedbackground}]
java -jar build/libs/MIPS32Decompiler.jar -n 34603008
Instruction     Fmt Decomposition   Decomp hex          Source
0x02100000      R  [0 16 16 0 0 0] [0 0x10 0x10 0 0 0]    nop
  Errors: rt: Got: 16 Expected: 0 rs: Got: 16 Expected: 0
\end{lstlisting}
\end{minipage}

\section{Domain-specific language}

In the previous section.~\ref{section:problem-statement} we described
the \emph{core} issues that our solution needs to address. 

Summarizing, we found that we want to be able to

\begin{itemize}
\item Get the six left-most bits from a 32-bit integer,
  i.e. the numerical opcode.
\item Infer the Format of the instruction from the opcode.
\item When necessary consult additional bitfields in the 32-bit integer to
      determine the particular instruction.
\item Validate other bitfields when necessary.
\item Convert the numerical representation into a mnemonic representation.
\end{itemize}

The first two items are trivial, the first is the result of a
bit-shift operation and as alluded to previously the Format is always
inferable from the Opcode, which means that we can either let each
opcode know its associated format or similarly associate formats
with sets of opcodes elsewhere. The specific approach will be covered
later, as will the reason it was chosen.

The subset of the MIPS32-instruction set that we have
implemented,\footnote{Floating point operations and a few others have
  been omitted.} is made up of a large number of operations so we would
like to design our system in such a manner that all of this
\emph{knowledge} pertaining to a particular instruction, viz. how to
validate it and represent it, be stored in a single place.

We want to express this as succinctly as possible, to make it as
legible as possible in one place all the defining characteristics
of an instruction.

Regardless of the instruction type we can express an instruction
as a tuple,

\begin{equation*}
(\langle \textit{identifying characteristics} \rangle, \langle
  \textit{validation requirements} \rangle, \langle \textit{mnemonic
    representation} \rangle)
\end{equation*}

For the R-type instructions we have that the identifying
characteristics is always expressed as a pair $(\textit{opcode},
\textit{funct})$, and that an I-type instruction is either identified
solely by its \opcode or by the pair $(\textit{opcode}, \textit{rt})$
in the case where \tt{opcode=0x01}, and J-type instructions are always
identified solely by their opcode.

Certain instructions must fulfill various conditions to be completely
valid. For an example, the instruction \texttt{MTC0} is identified by
$(\textit{opcode=0x10}, \textit{funct=0x00})$. To be valid, \tt{rs}
needs to be \tt{0x04}, while \tt{shamt} has to be \tt{0x00}.

Furthermore, its associated mnemonic pattern is \pattern{iname, rd, rt}.

This knowledge is encoded at a single point, in this specific case
in the \hlc{RTypeInstruction} enum, instructions in other formats are
specified in other classes in a similar fashion.

\begin{minted}[bgcolor=mintedbackground]{java}
/**
 * Move to coprocessor 0, move CPU register rt to register
 * rd in a coprocessor
 */
MTC0(0x10, 0x00, new Condition<RTypeInstruction, Integer>()
        .checkThat("rs", Int::rs).is(0x04).
                andThat("shamt", Int::shamt).is(0x00),
        new MnemonicPattern<>(Str::iname, Str::rd,  Str::rt)),
\end{minted}

The first two arguments specifies the identifier here, and
then there is an object which describes the conditions
that the instruction has to pass in its validation step, i.e.

\begin{minted}[bgcolor=mintedbackground]{java}
new Condition<RTypeInstruction, Integer>()
        .checkThat("rs", Int::rs).is(0x04).
                andThat("shamt", Int::shamt).is(0x00)
\end{minted}

The string arguments to \hlc{checkThat} as well as \hlc{andThat} are
used to create sensible error output when the validation fails, in the
same manner as JUnit assertion commands treat a leading string
argument.

The method references, \hlc{Int::rs} and \hlc{Int::shamt} are
references to methods that are able to retrieve those specified values
as integers from our instruction.

It is this object that is used to generate the error information for
partially valid instructions shown in
Listing.~\ref{listing:multiple-errors} and
Listing.~\ref{listing:partially-valid-instructions}.

Lastly the mnemonic pattern specifies in which order to output string
representations of the various bitfields with accordance to the
specification. It comma-separates its arguments, after the first two
(which are delimited by a single space).

The rest of the software is just plumbing. The \mij{Instruction} class
contains a \mij{Map} from \opcodem to for instance, to the
\mij{RTypeInstruction} enum which can continue decomposing the number,
identifying the instruction and populating an \mij{Instruction}
instance with the proper attributes so that it may be pretty-printed
later.

\section{Closing remarks}

By far, this is the most vile piece of software I have written.  The
take-away from the experience is to not try and wrangle the tools at
one's disposal to much. Java was ill-suited to model the problem as I
chose to model it. 

Instead a more object-oriented approach would have been more
appropriate, despite the fact that everything about this exercise is
devoid of any internal state.

One nice property of the DSL specification is that tests could be
automatically generated, but essentially these tests exercise the same
code-path. However, it did catch some errors.

Henceforth, it will be valuable to think about sequences of method
calls that may expose flaws in the design as opposed to testing single
routines. Also, I will move away from the \mij{static} keyword just to
appease the language.

Lastly, I am not entirely content with the content in this report.  It
is hard to write about that which one does not know without any
certainty. I tried to sketch out my intent early on which forced the
design into a mould that just wouldn't quite fit.

Writing out all the instruction specifications was however a breeze,
so in that respect the design works. Furthermore, collecting all the
information about an instruction in one place feels safe and easily
debug-able. It is also very easy to reference the material against
the MIPS32-instruction set specification.

\end{document}
